"""
Mock Azure Quantum REST client used to back a real Workspace
without making network calls. Returns real SDK models and ItemPaged.
"""

from typing import Callable, Iterable, Iterator, List, Optional
from datetime import datetime, UTC, timedelta

from azure.core.paging import ItemPaged
from azure.quantum.workspace import Workspace
from azure.quantum._client import ServicesClient
from azure.quantum._client.models import JobDetails, SessionDetails, ItemDetails


def _paged(items: List, page_size: int = 100) -> ItemPaged:
    """Create an ItemPaged that conforms to azure-core's contract.
    - get_next(token) returns a response payload
    - extract_data(response) returns (items_iterable, next_link)
    """

    def get_next(token):
        start = int(token) if token is not None else 0
        end = start + page_size
        page = items[start:end]
        next_link = str(end) if end < len(items) else None
        # Return a dict-like payload as expected by extract_data
        return {"items": page, "next_link": next_link}

    def extract_data(response):
        # Return (iterable, next_link) per azure.core.paging contract
        if response is None:
            return None, []
        items_iter = response.get("items") or []
        next_link = response.get("next_link")
        # azure.core.paging expects (continuation_token, items)
        return next_link, items_iter

    return ItemPaged(get_next, extract_data)


def _apply_filter(items: List, filter_expr: Optional[str]) -> List:
    """Apply a minimal OData-like filter generated by Workspace._create_filter.
    Supports:
    - startswith(Name, 'prefix')
    - Property eq 'value' (with or groups inside parentheses)
    - CreationTime ge/le YYYY-MM-DD
    Properties: Name, ItemType, JobType, ProviderId, Target, State, CreationTime
    """
    if not filter_expr:
        return items

    def matches(item) -> bool:
        expr = filter_expr
        # Handle startswith(Name, 'prefix') optionally combined with ' and '
        conds = [c.strip() for c in expr.split(" and ")]

        def eval_simple(condition: str) -> bool:
            # startswith(Name, 'x') (case-sensitive to match Workspace._create_filter)
            if condition.startswith("startswith("):
                try:
                    inside = condition[len("startswith(") : -1]
                    prop, value = inside.split(",", 1)
                    prop = prop.strip()
                    value = value.strip().strip("'")
                    name = getattr(item, "name", None)
                    return isinstance(name, str) and name.startswith(value)
                except Exception:
                    return False
            # Parenthesized OR: (A or B or C)
            if condition.startswith("(") and condition.endswith(")"):
                inner = condition[1:-1]
                parts = [p.strip() for p in inner.split(" or ")]
                return any(eval_simple(p) for p in parts)
            # Equality: Prop eq 'value'
            if " eq " in condition:
                try:
                    left, right = condition.split(" eq ", 1)
                    prop = left.strip()
                    val = right.strip().strip("'")
                    # Map property names to model attributes
                    mapping = {
                        "Name": "name",
                        "ItemType": "item_type",
                        "JobType": "job_type",
                        "ProviderId": "provider_id",
                        "Target": "target",
                        "State": "status",
                    }
                    attr = mapping.get(prop)
                    if not attr:
                        return False
                    item_val = getattr(item, attr, None)
                    return item_val == val
                except Exception:
                    return False
            # CreationTime ge/le YYYY-MM-DD
            if "CreationTime ge " in condition or "CreationTime le " in condition:
                try:
                    if " ge " in condition:
                        _, date_str = condition.split(" ge ", 1)
                        cmp_date = datetime.fromisoformat(date_str.strip())
                        ct = getattr(item, "creation_time", None)
                        return bool(ct) and ct.date() >= cmp_date.date()
                    if " le " in condition:
                        _, date_str = condition.split(" le ", 1)
                        cmp_date = datetime.fromisoformat(date_str.strip())
                        ct = getattr(item, "creation_time", None)
                        return bool(ct) and ct.date() <= cmp_date.date()
                except Exception:
                    return False
            return False

        return all(eval_simple(c) for c in conds)

    return [it for it in items if matches(it)]


class JobsOperations:
    def __init__(self, store: List[JobDetails]) -> None:
        self._store = store

    def create_or_replace(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        job_id: str,
        job_details: JobDetails,
    ) -> JobDetails:
        # Preserve provided status; default only if missing
        if getattr(job_details, "status", None) is None:
            job_details.status = "Submitted"
        # Ensure creation_time present
        if not getattr(job_details, "creation_time", None):
            job_details.creation_time = datetime.now(UTC)
        # Upsert by id
        for i, jd in enumerate(self._store):
            if jd.id == job_id:
                self._store[i] = job_details
                break
        else:
            self._store.append(job_details)
        return job_details

    def get(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        job_id: str,
    ) -> JobDetails:
        for jd in self._store:
            if jd.id == job_id:
                return jd
        raise KeyError(job_id)

    def list(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        top: int = 100,
        skip: int = 0,
    ) -> ItemPaged[JobDetails]:
        items = list(self._store)
        # Apply filter
        items = _apply_filter(items, filter)
        # Only basic orderby support for CreationTime asc/desc
        if orderby:
            try:
                prop, direction = orderby.split()
                if prop == "CreationTime":
                    items.sort(
                        key=lambda j: getattr(j, "creation_time", datetime.now(UTC)),
                        reverse=(direction == "desc"),
                    )
            except Exception:
                pass
        return _paged(items[skip : skip + top], page_size=top)


class SessionsOperations:
    def __init__(
        self, store: List[SessionDetails], jobs_store: List[JobDetails]
    ) -> None:
        self._store = store
        self._jobs_store = jobs_store

    def create_or_replace(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        session_id: str,
        session_details: SessionDetails,
    ) -> SessionDetails:
        if getattr(session_details, "status", None) is None:
            session_details.status = "WAITING"
        if not getattr(session_details, "creation_time", None):
            session_details.creation_time = datetime.utcnow()
        for i, sd in enumerate(self._store):
            if sd.id == session_id:
                self._store[i] = session_details
                break
        else:
            self._store.append(session_details)
        return session_details

    def close(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        session_id: str,
    ) -> SessionDetails:
        sd = self.get(subscription_id, resource_group_name, workspace_name, session_id)
        sd.status = "SUCCEEDED"
        return sd

    def get(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        session_id: str,
    ) -> SessionDetails:
        for sd in self._store:
            if sd.id == session_id:
                return sd
        raise KeyError(session_id)

    def list(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        skip: int = 0,
        top: int = 100,
    ) -> ItemPaged[SessionDetails]:
        items = list(self._store)
        items = _apply_filter(items, filter)
        if orderby:
            try:
                prop, direction = orderby.split()
                if prop == "CreationTime":
                    items.sort(
                        key=lambda s: getattr(s, "creation_time", datetime.now(UTC)),
                        reverse=(direction == "desc"),
                    )
            except Exception:
                pass
        return _paged(items[skip : skip + top], page_size=top)

    def jobs_list(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        session_id: str,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        skip: int = 0,
        top: int = 100,
    ) -> ItemPaged[JobDetails]:
        jobs = [
            j for j in self._jobs_store if getattr(j, "session_id", None) == session_id
        ]
        jobs = _apply_filter(jobs, filter)
        if orderby:
            try:
                prop, direction = orderby.split()
                if prop == "CreationTime":
                    jobs.sort(
                        key=lambda j: getattr(j, "creation_time", datetime.now(UTC)),
                        reverse=(direction == "desc"),
                    )
            except Exception:
                pass
        return _paged(jobs[skip : skip + top], page_size=top)


class TopLevelItemsOperations:
    def __init__(
        self, jobs_store: List[JobDetails], sessions_store: List[SessionDetails]
    ) -> None:
        self._jobs_store = jobs_store
        self._sessions_store = sessions_store

    def list(
        self,
        subscription_id: str,
        resource_group_name: str,
        workspace_name: str,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        top: int = 100,
        skip: int = 0,
    ) -> ItemPaged[ItemDetails]:
        items: List[ItemDetails] = []
        # Build JobDetails and SessionDetails via mapping-based init to mimic server responses
        for j in self._jobs_store:
            job_mapping = {
                "id": j.id,
                "itemType": "Job",
                "name": getattr(j, "name", j.id),
                "providerId": getattr(j, "provider_id", None),
                "target": getattr(j, "target", None),
                "creationTime": getattr(j, "creation_time", datetime.now(UTC)),
                "jobType": getattr(j, "job_type", None),
                # Status is read-only but present in service responses; include if available
                "status": getattr(j, "status", None),
            }
            items.append(JobDetails(job_mapping))
        for s in self._sessions_store:
            session_mapping = {
                "id": s.id,
                "itemType": "Session",
                "name": getattr(s, "name", s.id),
                "providerId": getattr(s, "provider_id", None),
                "target": getattr(s, "target", None),
                "creationTime": getattr(s, "creation_time", datetime.now(UTC)),
                # Required in model; set a sensible default for mock responses
                "jobFailurePolicy": getattr(s, "job_failure_policy", "Abort"),
                "status": getattr(s, "status", None),
            }
            items.append(SessionDetails(session_mapping))
        # Apply filter across heterogeneous items
        items = _apply_filter(items, filter)
        if orderby:
            try:
                prop, direction = orderby.split()
                if prop == "CreationTime":
                    items.sort(
                        key=lambda i: getattr(i, "creation_time", datetime.now(UTC)),
                        reverse=(direction == "desc"),
                    )
            except Exception:
                pass
        return _paged(items[skip : skip + top], page_size=top)


class MockServicesClient(ServicesClient):
    def __init__(self) -> None:
        # in-memory stores
        self._jobs_store: List[JobDetails] = []
        self._sessions_store: List[SessionDetails] = []
        # operations
        self.jobs = JobsOperations(self._jobs_store)
        self.sessions = SessionsOperations(self._sessions_store, self._jobs_store)
        self.top_level_items = TopLevelItemsOperations(
            self._jobs_store, self._sessions_store
        )


class WorkspaceMock(Workspace):
    def _create_client(self) -> ServicesClient:  # type: ignore[override]
        return MockServicesClient()


def seed_jobs(ws: WorkspaceMock) -> None:
    base = datetime.now(UTC) - timedelta(days=10)
    samples = [
        JobDetails(
            id="j-ionq-1",
            name="ionqJobA",
            provider_id="ionq",
            target="ionq.simulator",
            status="Succeeded",
            creation_time=base + timedelta(days=1),
            session_id="s-ionq-1",
            job_type="QuantumComputing",
        ),
        JobDetails(
            id="j-ionq-2",
            name="ionqJobB",
            provider_id="ionq",
            target="ionq.simulator",
            status="Failed",
            creation_time=base + timedelta(days=2),
            session_id="s-ionq-1",
        ),
        JobDetails(
            id="j-qh-1",
            name="qhJobA",
            provider_id="quantinuum",
            target="quantinuum.sim",
            status="Cancelled",
            creation_time=base + timedelta(days=3),
            session_id="s-ionq-2",
            job_type="QuantumChemistry",
        ),
        JobDetails(
            id="j-ms-1",
            name="msJobA",
            provider_id="microsoft",
            target="microsoft.estimator",
            status="Succeeded",
            creation_time=base + timedelta(days=4),
        ),
        JobDetails(
            id="j-ionq-ms-qc",
            name="ionqMsQC",
            provider_id="ionq",
            target="microsoft.estimator",
            status="Succeeded",
            creation_time=base + timedelta(days=5),
            job_type="QuantumComputing",
        ),
        JobDetails(
            id="j-rig-1",
            name="rigJobA",
            provider_id="rigetti",
            target="rigetti.qpu",
            status="Succeeded",
        ),
    ]
    for d in samples:
        ws._client.jobs.create_or_replace(
            ws.subscription_id, ws.resource_group, ws.name, job_id=d.id, job_details=d
        )


def seed_sessions(ws: WorkspaceMock) -> None:
    base = datetime.now(UTC) - timedelta(days=5)
    samples = [
        SessionDetails(
            id="s-ionq-1",
            name="sessionA",
            provider_id="ionq",
            target="ionq.simulator",
            status="Succeeded",
            creation_time=base + timedelta(days=1),
        ),
        SessionDetails(
            id="s-ionq-2",
            name="sessionB",
            provider_id="ionq",
            target="ionq.test",
            status="Succeeded",
            creation_time=base + timedelta(days=2),
        ),
    ]
    for s in samples:
        ws._client.sessions.create_or_replace(
            ws.subscription_id,
            ws.resource_group,
            ws.name,
            session_id=s.id,
            session_details=s,
        )


def create_default_workspace() -> WorkspaceMock:
    ws = WorkspaceMock(
        subscription_id="sub", resource_group="rg", name="ws", location="westus"
    )
    seed_jobs(ws)
    seed_sessions(ws)
    return ws
